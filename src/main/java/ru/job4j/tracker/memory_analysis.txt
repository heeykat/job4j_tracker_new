# Анализ работы памяти программы job4j_tracker через JConsole

## Инструмент
Использован инструмент: JConsole (Heap Memory Usage), с включением JMX для мониторинга JVM.

## Условия эксперимента
1. Приложение: job4j_tracker с реализацией MemTracker.
2. Действия:
   - Добавлено 100 000 заявок через пункт меню "CreateManyItems".
   - Удалены все заявки через "DeleteAllItems".
   - Выполнен ручной вызов сборщика мусора (Perform GC) в JConsole.
3. JVM запущена с флагами:
   -Xmx512m -Xms512m -XX:+UseG1GC -Dcom.sun.management.jmxremote

## Результаты наблюдений

### После добавления заявок
- Eden Space: 20 МБ → 200 МБ
- Survivor Space: 0 → 0,6 МБ
- Old Generation: 1 МБ → 5 МБ

Вывод:
- Большинство объектов создается в Eden Space.
- Небольшая часть объектов переживает Minor GC и попадает в Survivor и Old Gen.

### После удаления всех заявок
- Eden Space: 200 МБ → 40 МБ
- Survivor Space: 0,6 МБ → 18 МБ
- Old Generation: не увеличился

Вывод:
- Eden Space очищается при удалении объектов.
- Рост Survivor Space связан с временным удержанием объектов, переживших Minor GC.
- Old Gen не увеличился → долгоживущих объектов не образовалось.

### После ручного вызова GC (Perform GC)
- Eden Space: 40 МБ → 1 МБ
- Survivor Space: 18 МБ → 0 МБ
- Old Generation: не увеличился

Вывод:
- Все временные объекты освобождены, память возвращена системе.
- Old Gen стабилен → утечек памяти нет.

## Общий вывод
1. Программа корректно управляет памятью при массовом добавлении и удалении заявок.
2. Утечек памяти не наблюдается.
3. Сборщик мусора G1GC работает эффективно: Minor GC очищает Eden и Survivor Space, Old Gen остаётся стабильным.
4. Расширенный мониторинг через JConsole позволяет наблюдать за распределением объектов и оценивать работу GC в реальном времени.
